[[covert-side-channels]]
=== Covert and Side Channels

==== Definitions

The ability of an attacker to exfiltrate and retrieve a secret can be viewed as
the establishment of a communication channel. The attackerâ€™s goal is to
establish this communication channel across a security boundary.

For example, this could allow a user-mode process to read a secret manipulated
during a system call executed in supervisor mode.

Like any communication channel, there is an emitter (often called the Trojan)
trying to communicate the secret to the receiver (often called the Spy). Two
threat models are usually considered:

* *Covert Channels* refer to communication channels where both the Trojan
  and Spy are controlled by the attacker.
* *Side Channels* refer to communication channels where only the Spy is under
  the attacker's control. In this model, the Trojan's role is inadvertently
  played by the victim.

From the designer standpoint, one tries to protect against covert channels, since they represent a stronger attacker. If a design is secure with respect to covert channels, it is also secure with respect to side channels.

Communication channels can take several forms. A secret can be
communicated, or leaked, as secret-dependent power consumption measured with an
oscilloscope. Or a function's duration may depend on secret data; in this case,
the channel is a timing (covert or side) channel, the topic of the present document.

In a RISC-V hart, the cause of a timing channel can be two fold:

* *Architectural timing channels* occurs when a program executes different
  instructions, or the same instructions with different architectural
  side-effects, using a secret. For example, by branching on a condition
  involving a secret value, or by a multiplication having a latency dependent
  on the inputs. Architectural timing channels are software vulnerabilities as
  they arise from the instructions and data operated on by a program: they
  should not occur in security-minded programs.
* *Microarchitectural timing channels* occur due to changes in
  microarchitectural structures, to improve the performance of program, as a
  result of the execution of a sequence of instructions that may or may not be
  committed. The timing variation introduce is by design. Therefore, this type
  of timing channels can occur even in the absence of architectural timing
  channels, with a correct software implementation. In this case, timing
  variation can still occur due to the hardware implementation. For example, a
  _load_ instruction whose address is secret-dependent can induce a covert
  channel because of the cache hierarchy. The hierarchy stores the result of
  the _load_ access to lower the latency of future accesses to the same or
  neighboring addresses. As such, microarchitectural timing channels are not
  due to hardware implementation error per se, but rather to exploit the
  design.

[NOTE]
.Constant time programming
====
Constant time programming is a programming methodology that aims to generate
a program that doesn't leak secret data through a timing channel. It
encompasses the set of techniques (programming patterns, compiler
configurations, etc.) to achieve said result. Beware, depending on the context,
constant time programming may only consider architectural timing channels and
declare microarchitectural leakage out of scope.
====

[NOTE]
.Data-independent execution time
====
Constant time execution may not be required. A slightly weeker constraint is data-inpedente execution time, where the execution time may vary but independently from the data (and thus the secret value).
This is usually the actual security property that a designer want to achieve (see for example the RISC-V Zkt extension).
Beware, in lots of cases the "constant time" expression is used to denote "data-independent" time.
====

==== Measuring time

A critical aspect of timing channels is the possibility for the attacker to measure time.

A first issue arise because the timer/performance counters resides in the
Performance Monitoring Unit (PMU), which, often, has no knowledge of the
security domain in use and switches between different security domains.

As a result, the contents of the PMU are inherited between processes operating under different security domains after a security domain switch is performed.

Even though timing channels can be mitigated by enlightning the PMU, research has shown that there are other methods of creating timers that don't rely on ISA PMU primitives.
Indeed, the concept of time exsits independently from the PMU.
Time may be measured from the chip itself, for example by counting the number of executed instructions between two events, or from outside the chip with a timer triggered by observable events occuring in the targeted chip (e.g. specific power consumption patterns).

Hence, an implementation that seeks to provide a mitigation
against timing channels, in reference to its security model, must incorporate
various mechanisms, that in conjunction, abate the effectiveness of the spy's
communication channel.

Hardware and software techniques to limit covert
channels are discussed in <<mitigating-covert-channels>>.
Regardless of the
covert channel mitigations implemented, be they described herein or not, it is
recommended that a hart implements the following extensions: Zkt (and Zvkt for
V), Smstateen/Ssstateen, Smcntrpmf, and Sscofpmf.


==== Summary

With all the previous definitions in mind, one can generalize a timing channel
as the inheritance of microarchitectural state that depends on execution
history between two security domains. *Any microarchitectural state that
depends on execution history and impacts timing can be used to implement a
covert channel.* This includes cache memories, branch predictors, other kinds
of buffers (fetch buffers, etc.), finite state machines...

// Example FLUSH+RELOAD ?
